
## 堆排序

设有n个元素的序列k1,k2,...,kn，当且仅当满足所有非叶结点的值均大于等于（或小于等于）其子女结点的值时，称为大根堆（小根堆），即所有子树的根结点的值时最大（或最小）的。

堆排序（Heap Sort）是在直接选择排序方法的基础上借助于完全二叉树的结构而形成的一种排序方法，是完全二叉树顺序存储结构的应用。

堆排序的关键在于构建初始堆。

### 1. 初始堆的建立

对于一棵具有n个结点的完全二叉树，若从1开始对树中的结点编号，则编号为1~n/2的结点为分支结点，编号大于n/2的结点为叶结点。
对于每个编号为i的分支结点，它的左孩子和右孩子结点的编号分别为2i和2i+1。除编号为1的根结点外，对于每个编号为i的结点，其双亲结点的编号均为i/2。

筛选法建立初始堆的基本思想如下。

首先，将待排序的记录序列按原始顺序存放到一棵完全二叉树的各个结点中。然后根据堆的定义将完全二叉树中的子树都调整为堆。
由于完全二叉树中所有编号为i>n/2的叶结点Ki都没有孩子结点，以Ki这些结点为根的子树均已是堆，因此，我们只需要从完全二叉树中编号最大的分支结点Ki开始，依次对i=n/2, n/2 - 1, n/2 -2, …, 1为根的分支结点进行筛运算，以便形成以每个分支结点为根的堆。对树的根结点K1完成“筛选”后，则整个树就构成一个初始堆。

筛运算的具体过程如下。

以分支结点Ki为根结点，将根结点的关键字Ki与两个孩子中关键字较大者Kj(j=2i 或 j=2i+1)进行比较。

若Ki≥Kj，说明以Ki为根的子树已构成对，则筛选运算结束。

若Ki≤Kj，则将Ki 与 Kj互换位置；互换后若破坏了以Kj为根的堆，就继续将根结点Kj与新的孩子结点中关键字较大者进行比较，其余类推，直到Kj的关键字大于或等于两个孩子结点的关键字或者使其成为叶子结点时为止。
这样以Ki为根的子树就构成一个堆。筛运算的过程就像过筛子一样，将较小的关键字逐层筛选下去，把最大的关键字逐层筛选上来，所以将建堆的过程形象地称为“筛运算”。

### 2. 将删除堆顶元素后的完全二叉树重新调整为新堆

由堆的性质可知，删除堆顶元素后，这棵完全二叉树除了根结点可能违反堆的性质外，其余任何结点为根的二叉树仍然是堆。
因此，只需将根结点由上至下“筛选”到某个合适的位置，并使其左、右孩子结点的值都小于它或者成为叶结点即可。当筛选工作结束时，新堆已经构成。

### 3. 堆排序

堆排序是一种利用堆的特性进行排序的方法。堆排序的基本思想是：根据原始记录的关键字序列建立初始堆，使得堆顶元素时关键字最大的记录，然后删除堆顶元素并将其保存到数组中。
继续调整剩余的记录关键字序列使之重新构成一个新堆，再删除堆顶元素得到关键字为次大的记录并将其保存到数组中；如此反复，直到堆中只有一个记录时为止。
此时，数组中所有元素是一个按记录关键字从小到大顺序排列的有序序列。

实现堆排序的具体过程如下：
- （1）将待排序的记录按顺序输入完全二叉树中，然后用筛选函数Shift()建立初始堆；
- （2）将堆顶元素r[1]与堆中对吼一个的元素r[n]互换，使r[n]成为最大关键字；
- （3）用筛选函数Shift()将树根结点r[1]继续“筛选”到合适位置，重新构成新堆；
- （4）重复上述步骤（2）~（3），经过n-1次交换和筛选后，就完成了排序。