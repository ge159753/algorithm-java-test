
## 编辑距离

**编辑距离**是针对二个字符串（例如英文字）的差异程度的量化量测，量测方式是看至少需要多少次的处理才能将一个字符串变成另一个字符串。
编辑距离可以用在自然语言处理中，例如拼写检查可以根据一个拼错的字和其他正确的字的编辑距离，判断哪一个（或哪几个）是比较可能的字。

编辑距离有几种不同的定义，差异在可以对字符串进行的处理。
- 在莱文斯坦距离中，可以删除、加入、取代字符串中的任何一个字元，也是较常用的编辑距离定义，常常提到编辑距离时，指的就是莱文斯坦距离。
- 也存在其他编辑距离的定义方式，例如 Damerau-Levenshtein 距离是一种莱文斯坦距离的变种，但允许以单一操作交换相邻的两个字符（称为字符转置），如 AB→BA 的距离是 1（交换）而非 2（先删除再插入、或者两次替换）。
- LCS（最长公共子序列）距离只允许删除、加入字元。
- Jaro 距离只允许字符转置。
- 汉明距离只允许取代字元。

例子

kitten和sitting的莱文斯坦距离是3。将kitten变为sitting的最小处理方式如下：
1. kitten → sitten（将k改为s）
1. sitten → sittin（将e改为i）
1. sittin → sitting（最后加入g）

若是考虑LCS距离（只考虑加入及删除），LCS距离是5：
1. 删除位在第1个字的k
1. 在第1个字之前加入s
1. 删除位在第4个字的e
1. 在第4个字之前加入i
1. 在第6个字之前加入g

我们经常遇到的题目描述为：

给定一个源串和目标串，能够对源串进行如下操作：
1. 在给定位置上插入一个字符
1. 替换任意字符
1. 删除任意字符

写一个程序，返回最小操作数，使得对源串进行这些操作后等于目标串，源串和目标串的长度都小于2000。

在解法上也分为动态规划写法和递归写法，C语言写法可参考：https://github.com/youngwind/blog/issues/106 

[Java实现的动态规划的写法](https://github.com/lq920320/algorithm-java-test/blob/master/src/test/java/dynamic_programming/edit_distance/EditDistanceTest.java)
